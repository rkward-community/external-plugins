# the plugin code was generated by this script
# you should not change the plugin code directly, but this script
# note: this script only creates objects in your workspace,
# *EXCEPT* for the last call, see below.

local({
# set the output directory to overwrite the actual plugin
output.dir <- tempdir()
overwrite <- TRUE
# if you set guess.getters to TRUE, the resulting code will need RKWard >= 0.6.0
guess.getter <- FALSE

require(rkwarddev)

rk.set.language("en", "en_EN")
#rk.set.language("de", "de_DE")
#rk.set.language()

about.info <- rk.XML.about(
  name="rk.ANOVA",
  author=c(
    person(given="Meik", family="Michalke",
      email="meik.michalke@hhu.de", role=c("aut","cre"))),
  about=list(desc="RKWard GUI to conduct ANOVAs (using the ez package), pairwise t-Tests and plot interactions.",
    version="0.01-18", url="http://rkward.sf.net")
  )
dependencies.info <- rk.XML.dependencies(
  dependencies=list(rkward.min=ifelse(isTRUE(guess.getter), "0.6.0", "0.5.6")),
  package=list(c(name="ez"), c(name="sciplot"))
)

############
## ANOVA
############
anova.drp.design <- rk.XML.radio(
  label=i18n(
    en="Design",
    de="Design"
  ),
  options=i18n(
    en=list(
      "Between subjects"=c(val="between"),
      "Within subjects (repeated measures)"=c(val="within", chk=TRUE),
      "Mixed"=c(val="mixed")
    ),
    de=list(
      "Between subjects"=c(val="between"),
      "Within subjects (Messwiederholung)"=c(val="within", chk=TRUE),
      "Gemischt"=c(val="mixed")
    )
  )
)
var.select <- rk.XML.varselector(
  label=i18n(
    en="Select data",
    de="Wähle Daten"
  )
)
var.data <- rk.XML.varslot(
  label=i18n(
    en="Data (must be data.frame)",
    de="Daten (muss ein data.frame sein)"
  ),
  source=var.select, required=TRUE, classes="data.frame"
)
var.dv <- rk.XML.varslot(
  label=i18n(
    en="Dependent variable",
    de="Abhängige Variable"
  ),
  source=var.select, required=TRUE
)
var.wid <- rk.XML.varslot(
  label=i18n(
    en="Case/subject identifier",
    de="Fall/Personunterscheider"
  ),
  source=var.select
)
var.within <- rk.XML.varslot(
  label=i18n(
    en="Within subject variables",
    de="Within-Subject-Variablen"
  ),
  source=var.select, multi=TRUE
)
var.between <- rk.XML.varslot(
  label=i18n(
    en="Between subject variables",
    de="Between-Subject-Variablen"
  ),
  source=var.select, multi=TRUE
)
# observed data
var.select2 <- rk.XML.varselector(
  label=i18n(
    en="Select observed variables",
    de="Wähle beobachtete Variablen"
  )
)
var.observed <- rk.XML.varslot(
  label=i18n(
    en="Observed variables (not manipulated)",
    de="Beobachtete Variablen (nicht manipuliert)"
  ),
  source=var.select2, multi=TRUE
)

#diff
#reverse_diff
drp.vtype <- rk.XML.dropdown(
  label=i18n(
    en="Sums of squares type for unbalanced designs",
    de="Quadratsummentyp für unbalancierte Designs"
  ),
  options=i18n(
    en=list("Type 1"=c(val=1), "Type 2"=c(val=2, chk=TRUE), "Type 3"=c(val=3)),
    de=list("Typ 1"=c(val=1), "Typ 2"=c(val=2, chk=TRUE), "Typ 3"=c(val=3))
  )
)

# logic: only relevant for pure between designs
drp.white <- rk.XML.dropdown(
  label=i18n(
    en="Heteroscedasticity correction",
    de="Heteroskedastizitätskorrektur"
  ),
  options=i18n(
    en=list(
      "None"=c(val="false", chk=TRUE),
      "hc3 (Long & Ervin; default)"=c(val="hc3"),
      "hc0 (White)"=c(val="hc0"),
      "hc1 (Long & Ervin)"=c(val="hc1"),
      "hc2 (Long & Ervin)"=c(val="hc2"),
      "hc4 (Cribari-Neto)"=c(val="hc4")),
    de=list(
      "Keine"=c(val="false", chk=TRUE),
      "hc3 (Long & Ervin; Voreinstellung)"=c(val="hc3"),
      "hc0 (White)"=c(val="hc0"),
      "hc1 (Long & Ervin)"=c(val="hc1"),
      "hc2 (Long & Ervin)"=c(val="hc2"),
      "hc4 (Cribari-Neto)"=c(val="hc4"))
  )
)

check.extrainfo <- rk.XML.cbox(
  label=i18n(
    en="Show sums of squares, raw likelihood ratios etc.",
    de="Zeige Quadratsummen, rohe Likelihood Ratios etc."
  ),
  value="true"
)
check.aov <- rk.XML.cbox(
  label=i18n(
    en="Return 'aov' object",
    de="Gebe 'aov'-Objekt zurück"
  ),
  value="true",
  chk=TRUE
)

var.chk.suppress <- rk.XML.cbox(
  label=i18n(
    en="Suppress package loading messages",
    de="Unterdrücke Meldungen beim Laden von Paketen"
  ),
  value="true",
  chk=TRUE
)
save.results <- rk.XML.saveobj(
  i18n(
    en="Save results to workspace",
    de="Sichere Ergebnisse im Workspace"
  ),
  initial="anova.results"
)

tab1.data <- rk.XML.row(
  var.select,
  rk.XML.col(
    rk.XML.frame(var.data),
    rk.XML.frame(anova.drp.design),
    rk.XML.frame(var.dv, var.wid),
    rk.XML.frame(var.within, var.between)
  )
)

tab2.observed <- rk.XML.row(
  var.select2,
  rk.XML.col(
    rk.XML.frame(rk.XML.text(i18n(
      en="Observed variables are independent variables you have <b>already defined</b> as either between or within variables, but that were measured and <b>not manipulated</b>. They affect the calculated effect size (generalized eta seqared).",
      de="Beobachtete Variablen sind unabhängige Varaiblen die <b>bereits definiert sind</b>, entweder als Between- oder Within-Variablen; sie wurden allerdings nur gemessen und <b>nicht manipuliert</b>. Sie beeinflussen die berechnete Effektgröße (Generalisiertes Eta-Quadrat))"))),
    rk.XML.frame(var.observed)
  )
)

tab3.options <- rk.XML.row(
  rk.XML.col(
    rk.XML.frame(drp.vtype),
    rk.XML.frame(drp.white),
    rk.XML.frame(rk.XML.col(check.extrainfo),rk.XML.col(check.aov)),
    rk.XML.stretch(),
    var.chk.suppress,
    save.results
  )
)

full.dialog <- rk.XML.dialog(
  rk.XML.tabbook(
    label=i18n(
      en="ANOVA",
      de="ANOVA"
    ),
    tabs=i18n(
      en=list("Data"=tab1.data, "Observed"=tab2.observed, "Options"=tab3.options),
      de=list("Daten"=tab1.data, "Beobachtet"=tab2.observed, "Optionen"=tab3.options))
  ),
  label=i18n(
    en="ANOVA",
    de="ANOVA"
  )
)

## logic section to tie the second varslot to the data.frame
lgc.sect <- rk.XML.logic(
  rk.XML.connect(governor="current_object", client=var.data, set="available"),
  rk.XML.connect(governor=var.data, client=var.select, get="available", set="root"),
  anova.gov.data <- rk.XML.convert(sources=list(available=var.data), mode=c(notequals="")),
  anova.gov.between <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="between")),
  anova.gov.within <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="within")),
  anova.gov.mixed <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="mixed")),
  anova.gov.show.bvars <- rk.XML.convert(sources=list(anova.gov.between, anova.gov.mixed), mode=c(or=""), id.name="lgc_bvars"),
  anova.gov.show.wvars <- rk.XML.convert(sources=list(anova.gov.within, anova.gov.mixed), mode=c(or=""), id.name="lgc_vvars"),
  rk.XML.connect(governor=anova.gov.data, client=var.dv, set="enabled"),
  rk.XML.connect(governor=anova.gov.data, client=var.between, set="enabled"),
  rk.XML.connect(governor=anova.gov.data, client=var.within, set="enabled"),
  rk.XML.connect(governor=anova.gov.data, client=var.wid, set="enabled"),
  rk.XML.connect(governor=anova.gov.show.wvars, client=var.wid, set="required"),
  rk.XML.connect(governor=anova.gov.show.bvars, client=var.between, set="visible"),
  rk.XML.connect(governor=anova.gov.show.wvars, client=var.within, set="visible"),
  rk.XML.connect(governor=anova.gov.show.bvars, client=var.between, set="required"),
  rk.XML.connect(governor=anova.gov.show.wvars, client=var.within, set="required"),
  # observed data
  rk.XML.connect(governor=anova.gov.data, client=tab2.observed, set="enabled"),
  rk.XML.connect(governor=var.data, client=var.select2, get="available", set="root")
)

## JavaScript
js.calc <- rk.paste.JS(
  jsVarDv <- rk.JS.vars(var.dv, modifiers="shortname", join=", "),
  jsVarWid <- rk.JS.vars(var.wid, modifiers="shortname", join=", "),
  jsVarWithin <- rk.JS.vars(var.within, modifiers="shortname", join=", "),
  jsVarBetween <- rk.JS.vars(var.between, modifiers="shortname", join=", "),
  jsVarObserved <- rk.JS.vars(var.observed, modifiers="shortname", join=", "),
  ite(rkwarddev::id(drp.vtype, " == 3"),
    echo(
      i18n(
        en="\t# set contrasts for accurate type 3 ANOVA\n\toptions(contrasts=c(\"contr.sum\",\"contr.poly\"))\n",
        de="\t# setze Kontraste f&uuml;r korrekte Typ-3-ANOVA\n\toptions(contrasts=c(\"contr.sum\",\"contr.poly\"))\n"
      )
    )
  ),
  ite(rkwarddev::id(var.wid, " == \"\" & ", anova.drp.design, " == \"between\""),
    echo(
      i18n(
        en="\t# ezANOVA demands a subject identifier variable\n\t",
        de="\t# ezANOVA verlangt eine Variable zur Fall/Personunterscheidung\n\t"
      ),
      var.data, " <- cbind(", var.data ,", ez.subject.ID.dummy=factor(1:nrow(", var.data ,")))\n"
    )
  ),
  echo("\tanova.results <- ezANOVA("),
  ite(var.data, echo("\n\t\tdata=", var.data)),
  ite(var.dv, echo(",\n\t\tdv=.(", jsVarDv ,")")),
  ite(var.wid, echo(",\n\t\twid=.(", jsVarWid ,")"), ite(rkwarddev::id(anova.drp.design, " == \"between\""), echo(",\n\t\twid=.(ez.subject.ID.dummy)"))), # wid is needed anyway
  ite(rkwarddev::id(var.within, " != \"\" & ", anova.drp.design, " != \"between\""), echo(",\n\t\twithin=.(", jsVarWithin ,")")),
  ite(rkwarddev::id(var.between, " != \"\" & ", anova.drp.design, " != \"within\""), echo(",\n\t\tbetween=.(", jsVarBetween ,")")),
  ite(var.observed, echo(",\n\t\tobserved=.(", jsVarObserved ,")")),

  ite(rkwarddev::id(drp.vtype, " != 2"), echo(",\n\t\ttype=", drp.vtype)),
  ite(rkwarddev::id(drp.white, " != \"false\""), echo(",\n\t\twhite.adjust=\"", drp.white, "\"")),
  tf(check.extrainfo, opt="detailed"),
  tf(check.aov, opt="return_aov"),
  echo(")\n\n"),
  empty.e=TRUE
)

js.print <- rk.paste.JS(
  echo("rk.print(anova.results[[\"ANOVA\"]])\n"),
  echo(i18n(
    en="\tif(\"Mauchly's Test for Sphericity\" %in% names(anova.results)){
    rk.header(\"Mauchly's Test for Sphericity\", level=3)
    rk.print(anova.results[[\"Mauchly's Test for Sphericity\"]])
  } else {}\n",
    de="\tif(\"Mauchly's Test for Sphericity\" %in% names(anova.results)){
    rk.header(\"Sph&auml;rizit&auml;tstest nach Mauchly\", level=3)
    rk.print(anova.results[[\"Mauchly's Test for Sphericity\"]])
  } else {}\n"
    )
  ),
  echo(i18n(
    en="\tif(\"Sphericity Corrections\" %in% names(anova.results)){
    rk.header(\"Sphericity Corrections\", level=3)
    rk.print(anova.results[[\"Sphericity Corrections\"]])
  } else {}\n",
    de="\tif(\"Sphericity Corrections\" %in% names(anova.results)){
    rk.header(\"Sph&auml;rizit&auml;tskorrektur\", level=3)
    rk.print(anova.results[[\"Sphericity Corrections\"]])
  } else {}\n"
    )
  ),
  echo(i18n(
    en="\tif(\"Levene's Test for Homgeneity\" %in% names(anova.results)){
    rk.header(\"Levene's Test for Homgeneity\", level=3)
    rk.print(anova.results[[\"Levene's Test for Homgeneity\"]])
  } else {}\n",
    de="\tif(\"Levene's Test for Homgeneity\" %in% names(anova.results)){
    rk.header(\"Homogenit&auml;tstest nach Levene\", level=3)
    rk.print(anova.results[[\"Levene's Test for Homgeneity\"]])
  } else {}\n"
    )
  ),
  empty.e=TRUE
)

########
## prepare data
########
pd.var.selectVars <- rk.XML.varselector(
  label=i18n(
    en="Select data",
    de="Wähle Daten"
  )
)
pd.var.data <- rk.XML.varslot(
  label=i18n(
    en="Select all variables from one data.frame",
    de="Wähle alle Variablen aus einem data.frame"
  ),
  source=pd.var.selectVars, classes="data.frame"
)
pd.var.dependent <- rk.XML.varslot(
  label=i18n(
    en="Dependent/response vectors",
    de="Abhängige/Antwortvektor"
  ),
  source=pd.var.selectVars, multi=TRUE, min=2, required=TRUE
)
pd.inp.dependent <- rk.XML.input(
  label=i18n(
    en="Name for dependent variable",
    de="Bezeichnung für die abhängige Variable"
  ),
  initial="response", required=TRUE
)
pd.inp.condition <- rk.XML.input(
  label=i18n(
    en="Name for experimental condition",
    de="Bezeichnung für die Experimentalbedingung"
  ),
  initial="condition",
  required=TRUE
)
pd.chk.genCaseID <- rk.XML.cbox(
  label=i18n(
    en="Automatic case/subject identifier",
    de="Automatischer Fall/Personunterscheider"
  ),
  chk=TRUE
)
pd.inp.caseID <- rk.XML.input(
  label=i18n(
    en="Name for case/subject identifier",
    de="Bezeichnung für den Fall/Personunterscheider"
  ),
  initial="case",
  required=TRUE
)
pd.var.wid <- rk.XML.varslot(
  label=i18n(
    en="Case/subject identifier",
    de="Fall/Personunterscheider"
  ),
  source=pd.var.selectVars,
  required=TRUE
)
pd.var.between <- rk.XML.varslot(
  label=i18n(
    en="Between subject variables",
    de="Between-Subject-Variablen"
  ),
  source=pd.var.selectVars,
  multi=TRUE
)
pd.save.results <- rk.XML.saveobj(
  label=i18n(
    en="Save results to workspace",
    de="Sichere Ergebnisse im Workspace"
  ),
  initial="anova.data",
  chk=TRUE
)

pd.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    pd.var.selectVars,
    rk.XML.col(
      pd.var.data,
      pd.var.dependent,
      pd.inp.dependent,
      pd.inp.condition,
      pd.chk.genCaseID,
      pd.inp.caseID,
      pd.var.wid,
      pd.var.between,
      pd.save.results
    )
  ),
  label=i18n(
    en="Prepare within subject data",
    de="Bereite Within-Subject-Daten vor"
  )
)

## logic section to tie the varslot to the data.frame
  pd.lgc.sect <- rk.XML.logic(
    rk.XML.connect(governor="current_object", client=pd.var.data, set="available"),
    rk.XML.connect(governor=pd.var.data, client=pd.var.selectVars, get="available", set="root"),
#     pd.gov.data <- rk.XML.convert(sources=list(available=pd.var.data), mode=c(notequals="")),
#     rk.XML.connect(governor=pd.gov.data, client=pd.var.dependent, set="enabled"),
#     rk.XML.connect(governor=pd.gov.data, client=pd.inp.dependent, set="enabled"),
#     rk.XML.connect(governor=pd.gov.data, client=pd.inp.condition, set="enabled"),
#     rk.XML.connect(governor=pd.gov.data, client=pd.chk.genCaseID, set="enabled"),
    rk.XML.connect(governor=pd.chk.genCaseID, client=pd.inp.caseID, set="visible"),
    rk.XML.connect(governor=pd.chk.genCaseID, client=pd.var.wid, set="visible", not=TRUE)#,
#     rk.XML.connect(governor=pd.gov.data, client=pd.inp.caseID, set="enabled"),
#     rk.XML.connect(governor=pd.gov.data, client=pd.var.wid, set="enabled"),
#     rk.XML.connect(governor=pd.gov.data, client=pd.var.between, set="enabled")
  )

## JavaScript
pd.js.calc <- rk.paste.JS(
  pd.js.dep.names <- rk.JS.vars(pd.var.dependent, modifiers="shortname", join="\\\", \\\""),
  pd.js.dep <- rk.JS.vars(pd.var.dependent, join=",\\n\\t\\t\\t"),
  pd.js.wid <- rk.JS.vars(pd.var.wid, modifiers="shortname"),
  pd.js.between.short <- rk.JS.vars(pd.var.between, modifiers="shortname"),
  pd.js.between <- rk.JS.vars(pd.var.between, join=",\\n\\t\\t\\t", var.prefix="lng"),
  ite(pd.var.data,
    echo("\tnum.cases <- nrow(", pd.var.data,")\n"),
    rk.paste.JS(
      echo("\tnum.cases <- unique(sapply(list(\n\t\t\t", pd.js.dep),
      ite(rkwarddev::id("!", pd.chk.genCaseID , " && ", pd.var.wid),
        echo(",\n\t\t\t", pd.var.wid)),
      ite(pd.var.between,
        echo(",\n\t\t\t", pd.js.between)),
      echo("),\n\t\tlength))\n\tif(length(num.cases) > 1) {",
        i18n(
          en="\n\t\tstop(simpleError(\"Can't determine number of cases, variables don't have equal length!\"))",
          de="\n\t\tstop(simpleError(\"Kann die Anzahl der Fälle nicht ermitteln, Variablen haben nicht die gleiche Länge!\"))"
        ),
        "\n\t}\n"), level=3)
  ),
  ite(pd.var.dependent, echo("\tanova.conditions <- c(\"", pd.js.dep.names, "\")\n\tnum.conditions <- length(anova.conditions)\n\n")),
  ite(pd.var.between,
    rkwarddev::id("\tvar betweenVarsNames = ", pd.js.between.short, ".split(\"\\n\");\n",
    "\tvar betweenVars = ", pd.var.between, ".split(\"\\n\");"),
      "\tvar betweenVars = \"\";"),
  echo("\tanova.data <- data.frame("),
  ite(pd.var.dependent,
    echo("\n\t\t", pd.inp.dependent, "=c(\n\t\t\t", pd.js.dep, ")",
    ",\n\t\t", pd.inp.condition, "=factor(rep(anova.conditions, each=num.cases))")
  ),
  ite(rkwarddev::id(pd.chk.genCaseID , " && ", pd.inp.caseID),
    echo(",\n\t\t", pd.inp.caseID, "=factor(rep(1:num.cases, times=num.conditions))")),
  ite(rkwarddev::id("!", pd.chk.genCaseID , " && ", pd.var.wid),
    echo(",\n\t\t", pd.js.wid, "=factor(rep(", pd.var.wid, ", times=num.conditions))")),
  ite(pd.var.between, rkwarddev::id("\tfor (var i=0, len=betweenVarsNames.length; i<len; ++i ){\n",
    "\t\t\techo(\",\\n\\t\\t\" + betweenVarsNames[i] + \"=factor(rep(\" + betweenVars[i] + \", times=num.conditions))\");\n",
    "\t\t}"
  )),
  echo(",\n\t\tstringsAsFactors=FALSE)\n\n"),
  empty.e=TRUE
)

pd.js.print <- rk.paste.JS(
  echo("\trk.print(summary(anova.data))\n")
)

## make a whole component of the data preparation
pdata.component <- rk.plugin.component(
  i18n(
    en="Prepare within subject data",
    de="Bereite Within-Subject-Daten vor"
  ),
  xml=list(
    logic=pd.lgc.sect,
    dialog=pd.full.dialog),
  js=list(
    calculate=pd.js.calc,
    printout=pd.js.print,
    results.header=i18n(
      en="\"Prepare within subject data\"",
      de="\"Bereite Within-Subject-Daten vor\""
    )
  ),
  guess.getter=guess.getter,
  hierarchy=list("data", "ANOVA"),
  create=c("xml", "js"))

########
## pairwise t-tests
########
pt.var.selectVars <- rk.XML.varselector(
  label=i18n(
    en="Select data",
    de="Wähle Daten"
  )
)
pt.data.format <- rk.XML.radio(
  label=i18n(
    en="Data format",
    de="Datenformat"
  ),
  options=i18n(
    en=list(
      "Single (grouped) vector"=c(val="one", chk=TRUE),
      "Separate variables"=c(val="group")),
    de=list(
      "Einzelner (gruppierter) Vektor"=c(val="one", chk=TRUE),
      "Separate Variablen"=c(val="group"))
  )
)
pt.tvar.data <- rk.XML.varslot(
  label=i18n(
    en="Response vector",
    de="Antwortvektor"
  ),
  source=pt.var.selectVars
)
pt.tvar.group <- rk.XML.varslot(
  label=i18n(
    en="Grouping vector or factor",
    de="Gruppenvektor oder -faktor"
  ),
  source=pt.var.selectVars
)
pt.tvar.several <- rk.XML.varslot(
  label=i18n(
    en="Separate response vectors (>= 3)",
    de="Separate Antwortvektoren (>= 3)"
  ),
  source=pt.var.selectVars,
  multi=TRUE,
  min=3
)
pt.drp.adjust <- rk.XML.dropdown(
  label=i18n(
    en="Method for adjusting p values",
    de="Methode zur p-Wert-Adjustierung"
  ),
  options=i18n(
    en=list(
      "none"=c(val="none"),
      "Bonferroni"=c(val="bonferroni"), 
      "Holm"=c(val="holm", chk=TRUE),
      "Benjamini &amp; Hochberg (fdr)"=c(val="BH"),
      "Benjamini &amp; Yekutieli"=c(val="BY"),
      "Hochberg"=c(val="hochberg"),
      "Hommel"=c(val="hommel")),
    de=list(
      "keine"=c(val="none"),
      "Bonferroni"=c(val="bonferroni"), 
      "Holm"=c(val="holm", chk=TRUE),
      "Benjamini &amp; Hochberg (fdr)"=c(val="BH"),
      "Benjamini &amp; Yekutieli"=c(val="BY"),
      "Hochberg"=c(val="hochberg"),
      "Hommel"=c(val="hommel"))
  )
)
pt.chk.poolSD <- rk.XML.cbox(
  label=i18n(
    en="Pooled SD for all groups",
    de="Gepoolte Standardabweichung für alle Gruppen"
  ),
  value="true"
)
pt.chk.paired <- rk.XML.cbox(
  label=i18n(
    en="Paired t-Tests",
    de="Paarweise t-Tests"
  ),
  value="true",
  chk=TRUE
)
pt.radio.altern <- rk.XML.radio(
  label=i18n(
    en="Alternative hypothesis",
    de="Alternativhypothese"
  ),
  options=i18n(
    en=list(
      "Two-sided"=c(val="two.sided"),
      "First is greater"=c(val="greater"),
      "Second is greater"=c(val="less")),
    de=list(
      "Zweiseitig"=c(val="two.sided"),
      "Erster ist größer"=c(val="greater"),
      "Zweiter ist größer"=c(val="less"))
  )
)
pt.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    pt.var.selectVars,
    rk.XML.col(
      pt.data.format,
      rk.XML.frame(pt.tvar.data, pt.tvar.group, pt.tvar.several,
        label=i18n(
          en="Data",
          de="Daten"
        )
      ),
      rk.XML.frame(pt.drp.adjust,
        label=i18n(
          en="Alpha error correction",
          de="Alphafehlerkorrektur"
        )
      ),
      rk.XML.frame(pt.chk.poolSD, pt.chk.paired),
      pt.radio.altern
    )
  ),
  label=i18n(
    en="Pairwise t-Tests",
    de="Paarweise t-Tests"
  )
)

## logic
pt.lgc.sect <- rk.XML.logic(
    rk.XML.connect(governor=pt.chk.poolSD, client=pt.chk.paired, set="enabled", not=TRUE),
    rk.XML.connect(governor=pt.chk.paired, client=pt.chk.poolSD, set="enabled", not=TRUE),
    pt.gov.onevar <- rk.XML.convert(sources=list(string=pt.data.format), mode=c(equals="one")),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.data, set="visible"),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.data, set="required"),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.group, set="visible"),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.group, set="required"),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.several, set="visible", not=TRUE),
    rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.several, set="required", not=TRUE)
  )

## JavaScript
pt.js.calc <- rk.paste.JS(
  ite(rkwarddev::id(pt.data.format, " == \"one\""),
    rk.paste.JS(
      echo("\tpair.t.results <- pairwise.t.test(\n\t\t"),
      ite(pt.tvar.data, echo("x=", pt.tvar.data)),
      ite(pt.tvar.group, echo(",\n\t\tg=", pt.tvar.group)), level=3),
    rk.paste.JS(
      pt.vars.to.group <- rk.JS.vars(pt.tvar.several, join=", "),
      echo(i18n(
        en="\t# simple helper function to get the names of the objects\n",
        de="\t# einfache Hilfsfunktion um die Namen der Objekte zu ermitteln\n")
      ),
      echo("\tgrouping.vector <- function(...){\n\tunlist(lapply(match.call()[-1], function(x){rep(deparse(x), length(eval(x)))}))\n}\n"),
      ite(pt.tvar.several, echo(i18n(
          en="\t# create data and grouping vectors\n\tdata <- c(",
          de="\t# Erzeuge Daten- und Gruppenvektoren\n\tdata <- c("
        ),
        pt.vars.to.group, ")\n\tgroup <- grouping.vector(", pt.vars.to.group, ")\n\n")),
      echo(i18n(
        en="\t# the actual pairwise t-tests, using the prepared data\n\tpair.t.results <- pairwise.t.test(\n\t\t",
        de="\t# die eigentlichen paarweisen t-Tests, über die vorbereiteten Daten\n\tpair.t.results <- pairwise.t.test(\n\t\t")
      ),
      ite(pt.tvar.several, echo("x=data,\n\t\tg=group")), level=3
  )),
  ite(pt.drp.adjust, echo(",\n\t\tp.adjust.method=\"", pt.drp.adjust, "\"")),
  tf(pt.chk.poolSD, opt="pool.sd"),
  tf(pt.chk.paired, opt="paired"),
  ite(rkwarddev::id(pt.radio.altern, " != \"two.sided\""), echo(",\n\t\talternative=\"", pt.radio.altern, "\"")),
  echo(")\n\n"),
  empty.e=TRUE
)

pt.js.print <- rk.paste.JS(
  echo("rk.print(pair.t.results)\n"),
  empty.e=TRUE
)

## make a whole component of the t-test
pttest.component <- rk.plugin.component(
  i18n(
    en="Pairwise t-Tests",
    de="Paarweise t-Tests"
  ),
  xml=list(
    logic=pt.lgc.sect,
    dialog=pt.full.dialog),
  js=list(
    calculate=pt.js.calc,
    printout=pt.js.print,
    results.header=i18n(
      en="\"Pairwise t-Tests\"",
      de="\"Paarweise t-Tests\""
    )),
  guess.getter=guess.getter,
  hierarchy=list("analysis", "means", "t-tests"),
  create=c("xml", "js"))

###########
## interaction plot
###########
ip.var.selectVars <- rk.XML.varselector(
  label=i18n(
    en="Select data",
    de="Wähle Daten"
  )
)
ip.tvar.x <- rk.XML.varslot(
  label=i18n(
    en="Factor (x axis)",
    de="Faktor (X-Achse)"
  ),
  source=ip.var.selectVars,
  required=TRUE
)
ip.tvar.response <- rk.XML.varslot(
  label=i18n(
    en="Response vector",
    de="Antwortvektor"
  ),
  source=ip.var.selectVars,
  required=TRUE
)
ip.tvar.group <- rk.XML.varslot(
  label=i18n(
    en="Grouping factor (traces)",
    de="Gruppenfaktor (Stränge)"
  ),
  source=ip.var.selectVars
)
ip.rad.plottype <- rk.XML.radio(
  label=i18n(
    en="Plot type",
    de="Plot-Typ"
  ),
  options=i18n(
    en=list(
      "Lineplot"=c(val="line", chk=TRUE),
      "Bargraph"=c(val="bar")),
    de=list(
      "Linienplot"=c(val="line", chk=TRUE),
      "Balkengrafik"=c(val="bar"))
  )
)
ip.rad.ltype <- rk.XML.radio(
  label=i18n(
    en="Elements",
    de="Elemente"
  ),
  options=i18n(
    en=list(
      "Lines + points"=c(val="b", chk=TRUE),
      "Lines only"=c(val="l"),
      "Points only"=c(val="p")),
    de=list(
      "Linien + Punkte"=c(val="b", chk=TRUE),
      "nur Linien"=c(val="l"),
      "nur Punkte"=c(val="p"))
  )
)
ip.rad.btype <- rk.XML.radio(
  label=i18n(
    en="Bars",
    de="Balken"
  ),
  options=i18n(
    en=list(
      "Grouped bars"=c(val="group", chk=TRUE),
      "Split bars"=c(val="split")),
    de=list(
      "Gruppierte Balken"=c(val="group", chk=TRUE),
      "Geteilte Balken"=c(val="split"))
  )
)
ip.chk.se <- rk.XML.cbox(
  label=i18n(
    en="Standard error",
    de="Standardfehler"
  ),
  val="true",
  chk=TRUE
)
ip.chk.legend <- rk.XML.cbox(
  label=i18n(
    en="Legend",
    de="Legende"
  ),
  val="true",
  chk=TRUE
)
ip.inp.trace.label <- rk.XML.input(
  label=i18n(
    en="Legend label",
    de="Legendenbeschriftung"
  )
)
ip.plot.options <- rk.plotOptions()
ip.preview <- rk.XML.preview()

## logic
ip.lgc.sect <- rk.XML.logic(
    ip.gov.lineplot <- rk.XML.convert(sources=list(string=ip.rad.plottype), mode=c(equals="line")),
    rk.XML.connect(governor=ip.gov.lineplot, client=ip.rad.ltype, set="visible"),
    rk.XML.connect(governor=ip.gov.lineplot, client=ip.rad.btype, set="visible", not=TRUE),
    ip.gov.traces <- rk.XML.convert(sources=list(available=ip.tvar.group), mode=c(notequals="")),
    rk.XML.connect(governor=ip.gov.traces, client=ip.rad.btype, set="enabled"),
    rk.XML.connect(governor=ip.gov.traces, client=ip.chk.legend, set="enabled"),
    ip.gov.leglabel <- rk.XML.convert(sources=list(ip.gov.traces, state=ip.chk.legend), mode=c(and="")),
    rk.XML.connect(governor=ip.gov.leglabel, client=ip.inp.trace.label, set="enabled"),
    rk.XML.connect(governor=ip.tvar.x, client=ip.plot.options, get="available", set="xvar"),
    rk.XML.connect(governor=ip.tvar.response, client=ip.plot.options, get="available", set="yvar"),
    rk.XML.set(ip.plot.options, set="allow_type", to=FALSE)
  )

ip.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    ip.var.selectVars,
    rk.XML.col(
      rk.XML.frame(ip.tvar.x, ip.tvar.response, ip.tvar.group,
        label=i18n(
          en="Data",
          de="Daten"
        )
      ),
      rk.XML.stretch(),
      rk.XML.frame(
        rk.XML.row(
          rk.XML.col(ip.rad.plottype, ip.chk.se, ip.chk.legend, rk.XML.stretch()),
          rk.XML.col(ip.rad.ltype, ip.rad.btype, rk.XML.stretch())
        ),
        ip.inp.trace.label,
        ip.plot.options,
        ip.preview)
    )
  ),
  label=i18n(
    en="Interaction plot",
    de="Interaktionsplot"
  )
)

## JavaScript
ip.js.prnt <-   rk.paste.JS.graph(
  ite(rkwarddev::id(ip.rad.plottype, " == \"line\""),
    echo("\t\tlineplot.CI("),
    echo("\t\tbargraph.CI(")),
  ite(ip.tvar.x, echo("\n\t\t\tx.factor=", ip.tvar.x)),
  ite(ip.tvar.response, echo(",\n\t\t\tresponse=", ip.tvar.response)),
  ite(ip.tvar.group, echo(",\n\t\t\tgroup=", ip.tvar.group)),
  ite(rkwarddev::id(ip.rad.plottype, " == \"line\" & ", ip.rad.ltype, " != \"b\""), echo(",\n\t\t\ttype=\"", ip.rad.ltype, "\"")),
  ite(rkwarddev::id(ip.rad.plottype, " == \"bar\" & ", ip.rad.btype, " == \"split\""), echo(",\n\t\t\tsplit=TRUE")),
  ite(rkwarddev::id(ip.rad.plottype, " == \"line\" & !", ip.chk.legend, " & ", ip.tvar.group, " != \"\""), echo(",\n\t\t\tlegend=FALSE")),
  ite(rkwarddev::id(ip.rad.plottype, " == \"bar\" & ", ip.chk.legend, " == \"true\" & ", ip.tvar.group, " != \"\""), echo(",\n\t\t\tlegend=TRUE")),
  ite(rkwarddev::id(ip.chk.legend, " == \"true\" & ", ip.tvar.group, " != \"\" & ", ip.inp.trace.label, " != \"\""), echo(",\n\t\t\ttrace.label=\"", ip.inp.trace.label, "\"")),
  ite(rkwarddev::id("!", ip.chk.se), echo(",\n\t\t\tci.fun=function(x)c(mean(x, na.rm=TRUE), mean(x, na.rm=TRUE))")),
  rkwarddev::id("echo(", ip.plot.options, ".replace(/, /g, \",\\n\\t\\t\\t\"));"),
  echo(")"),
  plotOpts=ip.plot.options
)

## make a whole component of the interaction plot
plot.component <- rk.plugin.component(
  i18n(
    en="Interaction plot",
    de="Interaktionsplot"
  ),
  xml=list(
    logic=ip.lgc.sect,
    dialog=ip.full.dialog),
  js=list(
    results.header=i18n(
      en="\"Interaction plot\"",
      de="\"Interaktionsplot\""
    ),
    require="sciplot",
    doPrintout=ip.js.prnt),
  guess.getter=guess.getter,
  hierarchy=list("plots"),
  create=c("xml", "js"))


#############
## if you run the following function call, files will be written to tempdir!
#############
# this is where it get's serious, that is, here all of the above is put together into one plugin

rk.ANOVA.dir <<- rk.plugin.skeleton(
  about.info,
  path=output.dir,
  guess.getter=guess.getter,
  xml=list(
    logic=lgc.sect,
    dialog=full.dialog),
  js=list(
    require="ez",
    calculate=js.calc,
    printout=js.print,
    load.silencer=var.chk.suppress,
    results.header=i18n(
      en="\"ANOVA results\"",
      de="\"ANOVA-Ergebnisse\""
    )),
  pluginmap=list(name="ANOVA", hierarchy=list("analysis", "ANOVA")),
  components=list(pttest.component, plot.component, pdata.component),
  dependencies=dependencies.info,
  create=c("pmap", "xml", "js", "desc"),
  overwrite=overwrite,
  tests=FALSE,
#  edit=TRUE,
#  load=TRUE,
#  show=TRUE,
  hints=FALSE)

  # reset language
  rk.set.language()
})
