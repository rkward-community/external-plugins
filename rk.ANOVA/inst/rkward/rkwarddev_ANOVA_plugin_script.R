# the plugin code was generated by this script
# you should not change the plugin code directly, but this script
# note: this script only creates objects in your workspace,
# *EXCEPT* for the last call, see below.

local({
# set the output directory to overwrite the actual plugin
output.dir <- tempdir()
overwrite <- TRUE
# if you set guess.getters to TRUE, the resulting code will need RKWard >= 0.6.0
guess.getter <- FALSE

require(rkwarddev)

rk.set.language("en", "en_EN")
#rk.set.language("de", "de_DE")

about.info <- rk.XML.about(
	name="rk.ANOVA",
	author=c(
		person(given="Meik", family="Michalke",
			email="meik.michalke@hhu.de", role=c("aut","cre"))),
	about=list(desc="RKWard GUI to conduct ANOVAs (using the ez package), pairwise t-Tests and plot interactions.",
		version="0.01-18", url="http://rkward.sf.net")
	)
dependencies.info <- rk.XML.dependencies(
	dependencies=list(rkward.min=ifelse(isTRUE(guess.getter), "0.6.0", "0.5.6")),
	package=list(c(name="ez"), c(name="sciplot"))
)

############
## ANOVA
############
anova.drp.design <- rk.XML.radio("Design", options=i18n(
  en=list(
		"Between subjects"=c(val="between"),
		"Within subjects (repeated measures)"=c(val="within", chk=TRUE),
		"Mixed"=c(val="mixed")
	),
	de=list(
    "Between subjects"=c(val="between"),
    "Within subjects (Messwiederholung)"=c(val="within", chk=TRUE),
    "Gemischt"=c(val="mixed")
  ))
)
var.select <- rk.XML.varselector(label=i18n(en="Select data", de="Wähle Daten"))
var.data <- rk.XML.varslot(label=i18n(en="Data (must be data.frame)", de="Daten (müssen ein data.frame sein)"), source=var.select, required=TRUE, classes="data.frame")
var.dv <- rk.XML.varslot(label=i18n(en="Dependent variable", de="Abhängige Variable"), source=var.select, required=TRUE)
var.wid <- rk.XML.varslot(label=i18n(en="Case/subject identifier", de="Fall/Personunterscheider"), source=var.select)
var.within <- rk.XML.varslot(label=i18n(en="Within subject variables", de="Within Subject Variablen"), source=var.select, multi=TRUE)
var.between <- rk.XML.varslot(label=i18n(en="Between subject variables", de="Between Subject Variablen"), source=var.select, multi=TRUE)
# observed data
var.select2 <- rk.XML.varselector(label=i18n(en="Select observed variables", de="Wähle beobachtete Variablen"))
var.observed <- rk.XML.varslot(label=i18n(en="Observed variables (not manipulated)", de="Beobachtete Variablen (nicht manipuliert)"), source=var.select2, multi=TRUE)

#diff
#reverse_diff
drp.vtype <- rk.XML.dropdown(
	label=i18n(en="Sums of squares type for unbalanced designs", de="Quadratsummentyp für unbalancierte Designs"),
	options=i18n(
    en=list("Type 1"=c(val=1), "Type 2"=c(val=2, chk=TRUE), "Type 3"=c(val=3)),
    de=list("Typ 1"=c(val=1), "Typ 2"=c(val=2, chk=TRUE), "Typ 3"=c(val=3))))

# logic: only relevant for pure between designs
drp.white <- rk.XML.dropdown(
	label=i18n(en="Heteroscedasticity correction", de="Heteroskedastizitätskorrektur"),
	options=i18n(
    en=list(
      "None"=c(val="false", chk=TRUE),
      "hc3 (Long & Ervin; default)"=c(val="hc3"),
      "hc0 (White)"=c(val="hc0"),
      "hc1 (Long & Ervin)"=c(val="hc1"),
      "hc2 (Long & Ervin)"=c(val="hc2"),
      "hc4 (Cribari-Neto)"=c(val="hc4")),
		de=list(
      "Keine"=c(val="false", chk=TRUE),
      "hc3 (Long & Ervin; Voreinstellung)"=c(val="hc3"),
      "hc0 (White)"=c(val="hc0"),
      "hc1 (Long & Ervin)"=c(val="hc1"),
      "hc2 (Long & Ervin)"=c(val="hc2"),
      "hc4 (Cribari-Neto)"=c(val="hc4"))))

check.extrainfo <- rk.XML.cbox(label=i18n(en="Show sums of squares, raw likelihood ratios etc.", de="Zeige Quadratsummen, rohe Likelihood Ratios etc."), value="true")
check.aov <- rk.XML.cbox(label=i18n(en="Return 'aov' object", de="Gebe 'aov' Object zurück"), value="true", chk=TRUE)

var.chk.suppress <- rk.XML.cbox(label=i18n(en="Suppress package loading messages", de="Unterdrücke Meldungen beim Laden von Paketen"), value="true", chk=TRUE)
save.results <- rk.XML.saveobj(i18n(en="Save results to workspace", de="Sichere Ergebnisse im Workspace"), initial="anova.results")

tab1.data <- rk.XML.row(
		var.select,
		rk.XML.col(
			rk.XML.frame(var.data),
			rk.XML.frame(anova.drp.design),
			rk.XML.frame(var.dv, var.wid),
			rk.XML.frame(var.within, var.between)
		)
	)

tab2.observed <- rk.XML.row(
		var.select2,
		rk.XML.col(
			rk.XML.frame(rk.XML.text(i18n(
        en="Observed variables are independent variables you have <b>already defined</b> as either between or within variables, but that were measured and <b>not manipulated</b>. They affect the calculated effect size (generalized eta seqared).",
        de="Beobachtete Variablen sind unabhängige Varaiblen die <b>bereits definiert sind</b>, entweder als Between oder Within Variablen, die allerdings nur gemessen und <b>nicht manipuliert</b> wurden. Sie beeinflussen die berechnete Effektgröße (Generalisiertes Eta-Quadrat))"))),
			rk.XML.frame(var.observed)
		)
	)

tab3.options <- rk.XML.row(
		rk.XML.col(
			rk.XML.frame(drp.vtype),
			rk.XML.frame(drp.white),
			rk.XML.frame(rk.XML.col(check.extrainfo),rk.XML.col(check.aov)),
			rk.XML.stretch(),
			var.chk.suppress,
			save.results
		)
	)

full.dialog <- rk.XML.dialog(rk.XML.tabbook(label="ANOVA",
		tabs=i18n(
      en=list("Data"=tab1.data, "Observed"=tab2.observed, "Options"=tab3.options),
      de=list("Daten"=tab1.data, "Beobachtet"=tab2.observed, "Optionen"=tab3.options))
	), label="ANOVA")

## logic section to tie the second varslot to the data.frame
	lgc.sect <- rk.XML.logic(
		rk.XML.connect(governor="current_object", client=var.data, set="available"),
		rk.XML.connect(governor=var.data, client=var.select, get="available", set="root"),
		anova.gov.data <- rk.XML.convert(sources=list(available=var.data), mode=c(notequals="")),
		anova.gov.between <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="between")),
		anova.gov.within <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="within")),
		anova.gov.mixed <- rk.XML.convert(sources=list(string=anova.drp.design), mode=c(equals="mixed")),
		anova.gov.show.bvars <- rk.XML.convert(sources=list(anova.gov.between, anova.gov.mixed), mode=c(or=""), id.name="lgc_bvars"),
		anova.gov.show.wvars <- rk.XML.convert(sources=list(anova.gov.within, anova.gov.mixed), mode=c(or=""), id.name="lgc_vvars"),
		rk.XML.connect(governor=anova.gov.data, client=var.dv, set="enabled"),
		rk.XML.connect(governor=anova.gov.data, client=var.between, set="enabled"),
		rk.XML.connect(governor=anova.gov.data, client=var.within, set="enabled"),
		rk.XML.connect(governor=anova.gov.data, client=var.wid, set="enabled"),
		rk.XML.connect(governor=anova.gov.show.wvars, client=var.wid, set="required"),
		rk.XML.connect(governor=anova.gov.show.bvars, client=var.between, set="visible"),
		rk.XML.connect(governor=anova.gov.show.wvars, client=var.within, set="visible"),
		rk.XML.connect(governor=anova.gov.show.bvars, client=var.between, set="required"),
		rk.XML.connect(governor=anova.gov.show.wvars, client=var.within, set="required"),
		# observed data
		rk.XML.connect(governor=anova.gov.data, client=tab2.observed, set="enabled"),
		rk.XML.connect(governor=var.data, client=var.select2, get="available", set="root")
	)

## JavaScript
js.calc <- rk.paste.JS(
	jsVarDv <- rk.JS.vars(var.dv, modifiers="shortname", join=", "),
	jsVarWid <- rk.JS.vars(var.wid, modifiers="shortname", join=", "),
	jsVarWithin <- rk.JS.vars(var.within, modifiers="shortname", join=", "),
	jsVarBetween <- rk.JS.vars(var.between, modifiers="shortname", join=", "),
	jsVarObserved <- rk.JS.vars(var.observed, modifiers="shortname", join=", "),
	ite(rkwarddev::id(drp.vtype, " == 3"), echo("\t# set contrasts for accurate type 3 ANOVA\n\toptions(contrasts=c(\"contr.sum\",\"contr.poly\"))\n")),
	ite(rkwarddev::id(var.wid, " == \"\" & ", anova.drp.design, " == \"between\""), echo("\t# ezANOVA demands a subject identifier variable\n\t", var.data, " <- cbind(", var.data ,", ez.subject.ID.dummy=factor(1:nrow(", var.data ,")))\n")),
	echo("\tanova.results <- ezANOVA("),
	ite(var.data, echo("\n\t\tdata=", var.data)),
	ite(var.dv, echo(",\n\t\tdv=.(", jsVarDv ,")")),
	ite(var.wid, echo(",\n\t\twid=.(", jsVarWid ,")"), ite(rkwarddev::id(anova.drp.design, " == \"between\""), echo(",\n\t\twid=.(ez.subject.ID.dummy)"))), # wid is needed anyway
	ite(rkwarddev::id(var.within, " != \"\" & ", anova.drp.design, " != \"between\""), echo(",\n\t\twithin=.(", jsVarWithin ,")")),
	ite(rkwarddev::id(var.between, " != \"\" & ", anova.drp.design, " != \"within\""), echo(",\n\t\tbetween=.(", jsVarBetween ,")")),
	ite(var.observed, echo(",\n\t\tobserved=.(", jsVarObserved ,")")),

	ite(rkwarddev::id(drp.vtype, " != 2"), echo(",\n\t\ttype=", drp.vtype)),
	ite(rkwarddev::id(drp.white, " != \"false\""), echo(",\n\t\twhite.adjust=\"", drp.white, "\"")),
	tf(check.extrainfo, opt="detailed"),
	tf(check.aov, opt="return_aov"),
	echo(")\n\n"),
	empty.e=TRUE
)

js.print <- rk.paste.JS(
	echo("rk.print(anova.results[[\"ANOVA\"]])\n"),
	echo("\tif(\"Mauchly's Test for Sphericity\" %in% names(anova.results)){
		rk.header(\"Mauchly's Test for Sphericity\", level=3)
		rk.print(anova.results[[\"Mauchly's Test for Sphericity\"]])
	} else {}\n"),
	echo("\tif(\"Sphericity Corrections\" %in% names(anova.results)){
		rk.header(\"Sphericity Corrections\", level=3)
		rk.print(anova.results[[\"Sphericity Corrections\"]])
	} else {}\n"),
	echo("\tif(\"Levene's Test for Homgeneity\" %in% names(anova.results)){
		rk.header(\"Levene's Test for Homgeneity\", level=3)
		rk.print(anova.results[[\"Levene's Test for Homgeneity\"]])
	} else {}\n"),
	empty.e=TRUE
)

########
## prepare data
########
pd.var.selectVars <- rk.XML.varselector(label="Select data")
pd.var.data <- rk.XML.varslot(label="Select all variables from one data.frame", source=pd.var.selectVars, classes="data.frame")
pd.var.dependent <- rk.XML.varslot(label="Dependent/response vectors", source=pd.var.selectVars, multi=TRUE, min=2, required=TRUE)
pd.inp.dependent <- rk.XML.input("Name for dependent variable", initial="response", required=TRUE)
pd.inp.condition <- rk.XML.input("Name for experimental condition", initial="condition", required=TRUE)
pd.chk.genCaseID <- rk.XML.cbox("Automatic case/subject identifier", chk=TRUE)
pd.inp.caseID <- rk.XML.input("Name for case/subject identifier", initial="case", required=TRUE)
pd.var.wid <- rk.XML.varslot(label="Case/subject identifier", source=pd.var.selectVars, required=TRUE)
pd.var.between <- rk.XML.varslot(label="Between subject variables", source=pd.var.selectVars, multi=TRUE)
pd.save.results <- rk.XML.saveobj("Save results to workspace", initial="anova.data", chk=TRUE)

pd.full.dialog <- rk.XML.dialog(rk.XML.row(
	pd.var.selectVars,
	rk.XML.col(
		pd.var.data,
		pd.var.dependent,
		pd.inp.dependent,
		pd.inp.condition,
		pd.chk.genCaseID,
		pd.inp.caseID,
		pd.var.wid,
		pd.var.between,
		pd.save.results
	)
), label="Prepare within subject data")

## logic section to tie the varslot to the data.frame
	pd.lgc.sect <- rk.XML.logic(
		rk.XML.connect(governor="current_object", client=pd.var.data, set="available"),
		rk.XML.connect(governor=pd.var.data, client=pd.var.selectVars, get="available", set="root"),
# 		pd.gov.data <- rk.XML.convert(sources=list(available=pd.var.data), mode=c(notequals="")),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.var.dependent, set="enabled"),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.inp.dependent, set="enabled"),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.inp.condition, set="enabled"),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.chk.genCaseID, set="enabled"),
		rk.XML.connect(governor=pd.chk.genCaseID, client=pd.inp.caseID, set="visible"),
		rk.XML.connect(governor=pd.chk.genCaseID, client=pd.var.wid, set="visible", not=TRUE)#,
# 		rk.XML.connect(governor=pd.gov.data, client=pd.inp.caseID, set="enabled"),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.var.wid, set="enabled"),
# 		rk.XML.connect(governor=pd.gov.data, client=pd.var.between, set="enabled")
	)

## JavaScript
pd.js.calc <- rk.paste.JS(
	pd.js.dep.names <- rk.JS.vars(pd.var.dependent, modifiers="shortname", join="\\\", \\\""),
	pd.js.dep <- rk.JS.vars(pd.var.dependent, join=",\\n\\t\\t\\t"),
	pd.js.wid <- rk.JS.vars(pd.var.wid, modifiers="shortname"),
	pd.js.between.short <- rk.JS.vars(pd.var.between, modifiers="shortname"),
	pd.js.between <- rk.JS.vars(pd.var.between, join=",\\n\\t\\t\\t", var.prefix="lng"),
	ite(pd.var.data,
		echo("\tnum.cases <- nrow(", pd.var.data,")\n"),
		rk.paste.JS(
			echo("\tnum.cases <- unique(sapply(list(\n\t\t\t", pd.js.dep),
			ite(rkwarddev::id("!", pd.chk.genCaseID , " && ", pd.var.wid),
				echo(",\n\t\t\t", pd.var.wid)),
			ite(pd.var.between,
				echo(",\n\t\t\t", pd.js.between)),
			echo("),\n\t\tlength))\n\tif(length(num.cases) > 1) {",
				"\n\t\tstop(simpleError(\"Can't determine number of cases, variables don't have equal length!\"))",
				"\n\t}\n"), level=3)
	),
	ite(pd.var.dependent, echo("\tanova.conditions <- c(\"", pd.js.dep.names, "\")\n\tnum.conditions <- length(anova.conditions)\n\n")),
	ite(pd.var.between,
		rkwarddev::id("\tvar betweenVarsNames = ", pd.js.between.short, ".split(\"\\n\");\n",
		"\tvar betweenVars = ", pd.var.between, ".split(\"\\n\");"),
			"\tvar betweenVars = \"\";"),
	echo("\tanova.data <- data.frame("),
	ite(pd.var.dependent,
		echo("\n\t\t", pd.inp.dependent, "=c(\n\t\t\t", pd.js.dep, ")",
		",\n\t\t", pd.inp.condition, "=factor(rep(anova.conditions, each=num.cases))")
	),
	ite(rkwarddev::id(pd.chk.genCaseID , " && ", pd.inp.caseID),
		echo(",\n\t\t", pd.inp.caseID, "=factor(rep(1:num.cases, times=num.conditions))")),
	ite(rkwarddev::id("!", pd.chk.genCaseID , " && ", pd.var.wid),
		echo(",\n\t\t", pd.js.wid, "=factor(rep(", pd.var.wid, ", times=num.conditions))")),
	ite(pd.var.between, rkwarddev::id("\tfor (var i=0, len=betweenVarsNames.length; i<len; ++i ){\n",
		"\t\t\techo(\",\\n\\t\\t\" + betweenVarsNames[i] + \"=factor(rep(\" + betweenVars[i] + \", times=num.conditions))\");\n",
		"\t\t}"
	)),
	echo(",\n\t\tstringsAsFactors=FALSE)\n\n"),
	empty.e=TRUE
)

pd.js.print <- rk.paste.JS(
	echo("\trk.print(summary(anova.data))\n")
)

## make a whole component of the data preparation
pdata.component <- rk.plugin.component("Prepare within subject data",
	xml=list(
		logic=pd.lgc.sect,
		dialog=pd.full.dialog),
	js=list(
		calculate=pd.js.calc,
		printout=pd.js.print),
	guess.getter=guess.getter,
	hierarchy=list("data", "ANOVA"),
	create=c("xml", "js"))

########
## pairwise t-tests
########
pt.var.selectVars <- rk.XML.varselector(label="Select data")
pt.data.format <- rk.XML.radio(
	label="Data format",
	options=list(
		"Single (grouped) vector"=c(val="one", chk=TRUE),
		"Separate variables"=c(val="group")
	))
pt.tvar.data <- rk.XML.varslot(label="Response vector", source=pt.var.selectVars)
pt.tvar.group <- rk.XML.varslot(label="Grouping vector or factor", source=pt.var.selectVars)
pt.tvar.several <- rk.XML.varslot(label="Separate response vectors (>= 3)", source=pt.var.selectVars, multi=TRUE, min=3)
pt.drp.adjust <- rk.XML.dropdown(
	label="Method for adjusting p values",
	options=list(
		"none"=c(val="none"),
		"Bonferroni"=c(val="bonferroni"), 
		"Holm"=c(val="holm", chk=TRUE),
		"Benjamini &amp; Hochberg (fdr)"=c(val="BH"),
		"Benjamini &amp; Yekutieli"=c(val="BY"),
		"Hochberg"=c(val="hochberg"),
		"Hommel"=c(val="hommel")
	))
pt.chk.poolSD <- rk.XML.cbox("Pooled SD for all groups", value="true")
pt.chk.paired <- rk.XML.cbox("Paired t-Tests", value="true", chk=TRUE)
pt.radio.altern <- rk.XML.radio("Alternative hypothesis",
		options=list(
			"Two-sided"=c(val="two.sided"),
			"First is greater"=c(val="greater"),
			"Second is greater"=c(val="less")
		)
	)
pt.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		pt.var.selectVars,
		rk.XML.col(
			pt.data.format,
			rk.XML.frame(pt.tvar.data, pt.tvar.group, pt.tvar.several, label="Data"),
			rk.XML.frame(pt.drp.adjust, label="Alpha error correction"),
			rk.XML.frame(pt.chk.poolSD, pt.chk.paired),
			pt.radio.altern
		)
	), label="Pairwise t-Tests")

## logic
pt.lgc.sect <- rk.XML.logic(
		rk.XML.connect(governor=pt.chk.poolSD, client=pt.chk.paired, set="enabled", not=TRUE),
		rk.XML.connect(governor=pt.chk.paired, client=pt.chk.poolSD, set="enabled", not=TRUE),
		pt.gov.onevar <- rk.XML.convert(sources=list(string=pt.data.format), mode=c(equals="one")),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.data, set="visible"),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.data, set="required"),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.group, set="visible"),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.group, set="required"),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.several, set="visible", not=TRUE),
		rk.XML.connect(governor=pt.gov.onevar, client=pt.tvar.several, set="required", not=TRUE)
	)

## JavaScript
pt.js.calc <- rk.paste.JS(
	ite(rkwarddev::id(pt.data.format, " == \"one\""),
		rk.paste.JS(
			echo("\tpair.t.results <- pairwise.t.test(\n\t\t"),
			ite(pt.tvar.data, echo("x=", pt.tvar.data)),
			ite(pt.tvar.group, echo(",\n\t\tg=", pt.tvar.group)), level=3),
		rk.paste.JS(
			pt.vars.to.group <- rk.JS.vars(pt.tvar.several, join=", "),
			echo("\t# simple helper function to get the names of the objects\n"),
			echo("\tgrouping.vector <- function(...){\n\tunlist(lapply(match.call()[-1], function(x){rep(deparse(x), length(eval(x)))}))\n}\n"),
			ite(pt.tvar.several, echo("\t# create data and grouping vectors\n\tdata <- c(", pt.vars.to.group, ")\n\tgroup <- grouping.vector(", pt.vars.to.group, ")\n\n")),
			echo("\t# the actual pairwise t-tests, using the prepared data\n\tpair.t.results <- pairwise.t.test(\n\t\t"),
			ite(pt.tvar.several, echo("x=data,\n\t\tg=group")), level=3
	)),
	ite(pt.drp.adjust, echo(",\n\t\tp.adjust.method=\"", pt.drp.adjust, "\"")),
	tf(pt.chk.poolSD, opt="pool.sd"),
	tf(pt.chk.paired, opt="paired"),
	ite(rkwarddev::id(pt.radio.altern, " != \"two.sided\""), echo(",\n\t\talternative=\"", pt.radio.altern, "\"")),
	echo(")\n\n"),
	empty.e=TRUE
)

pt.js.print <- rk.paste.JS(
	echo("rk.print(pair.t.results)\n"),
	empty.e=TRUE
)

## make a whole component of the t-test
pttest.component <- rk.plugin.component("Pairwise t-Tests",
	xml=list(
		logic=pt.lgc.sect,
		dialog=pt.full.dialog),
	js=list(
		calculate=pt.js.calc,
		printout=pt.js.print),
	guess.getter=guess.getter,
	hierarchy=list("analysis", "means", "t-tests"),
	create=c("xml", "js"))

###########
## interaction plot
###########
ip.var.selectVars <- rk.XML.varselector(label="Select data")
ip.tvar.x <- rk.XML.varslot(label="Factor (x axis)", source=ip.var.selectVars, required=TRUE)
ip.tvar.response <- rk.XML.varslot(label="Response vector", source=ip.var.selectVars, required=TRUE)
ip.tvar.group <- rk.XML.varslot(label="Grouping factor (traces)", source=ip.var.selectVars)
ip.rad.plottype <- rk.XML.radio("Plot type", options=list(
	"Lineplot"=c(val="line", chk=TRUE),
	"Bargraph"=c(val="bar")))
ip.rad.ltype <- rk.XML.radio("Elements", options=list(
	"Lines + points"=c(val="b", chk=TRUE),
	"Lines only"=c(val="l"),
	"Points only"=c(val="p")))
ip.rad.btype <- rk.XML.radio("Bars", options=list(
	"Group bars"=c(val="group", chk=TRUE),
	"Split bars"=c(val="split")))
ip.chk.se <- rk.XML.cbox("Standard error", val="true", chk=TRUE)
ip.chk.legend <- rk.XML.cbox("Legend", val="true", chk=TRUE)
ip.inp.trace.label <- rk.XML.input("Legend label")
ip.plot.options <- rk.plotOptions()
ip.preview <- rk.XML.preview()

## logic
ip.lgc.sect <- rk.XML.logic(
		ip.gov.lineplot <- rk.XML.convert(sources=list(string=ip.rad.plottype), mode=c(equals="line")),
		rk.XML.connect(governor=ip.gov.lineplot, client=ip.rad.ltype, set="visible"),
		rk.XML.connect(governor=ip.gov.lineplot, client=ip.rad.btype, set="visible", not=TRUE),
		ip.gov.traces <- rk.XML.convert(sources=list(available=ip.tvar.group), mode=c(notequals="")),
		rk.XML.connect(governor=ip.gov.traces, client=ip.rad.btype, set="enabled"),
		rk.XML.connect(governor=ip.gov.traces, client=ip.chk.legend, set="enabled"),
		ip.gov.leglabel <- rk.XML.convert(sources=list(ip.gov.traces, state=ip.chk.legend), mode=c(and="")),
		rk.XML.connect(governor=ip.gov.leglabel, client=ip.inp.trace.label, set="enabled"),
		rk.XML.connect(governor=ip.tvar.x, client=ip.plot.options, get="available", set="xvar"),
		rk.XML.connect(governor=ip.tvar.response, client=ip.plot.options, get="available", set="yvar"),
		rk.XML.set(ip.plot.options, set="allow_type", to=FALSE)
	)

ip.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		ip.var.selectVars,
		rk.XML.col(
			rk.XML.frame(ip.tvar.x, ip.tvar.response, ip.tvar.group, label="Data"),
			rk.XML.stretch(),
			rk.XML.frame(
				rk.XML.row(
					rk.XML.col(ip.rad.plottype, ip.chk.se, ip.chk.legend, rk.XML.stretch()),
					rk.XML.col(ip.rad.ltype, ip.rad.btype, rk.XML.stretch())
				),
				ip.inp.trace.label,
				ip.plot.options,
				ip.preview)
		)
	), label="Interaction plot")

## JavaScript
ip.js.prnt <- 	rk.paste.JS.graph(
	ite(rkwarddev::id(ip.rad.plottype, " == \"line\""),
		echo("\t\tlineplot.CI("),
		echo("\t\tbargraph.CI(")),
	ite(ip.tvar.x, echo("\n\t\t\tx.factor=", ip.tvar.x)),
	ite(ip.tvar.response, echo(",\n\t\t\tresponse=", ip.tvar.response)),
	ite(ip.tvar.group, echo(",\n\t\t\tgroup=", ip.tvar.group)),
	ite(rkwarddev::id(ip.rad.plottype, " == \"line\" & ", ip.rad.ltype, " != \"b\""), echo(",\n\t\t\ttype=\"", ip.rad.ltype, "\"")),
	ite(rkwarddev::id(ip.rad.plottype, " == \"bar\" & ", ip.rad.btype, " == \"split\""), echo(",\n\t\t\tsplit=TRUE")),
	ite(rkwarddev::id(ip.rad.plottype, " == \"line\" & !", ip.chk.legend, " & ", ip.tvar.group, " != \"\""), echo(",\n\t\t\tlegend=FALSE")),
	ite(rkwarddev::id(ip.rad.plottype, " == \"bar\" & ", ip.chk.legend, " == \"true\" & ", ip.tvar.group, " != \"\""), echo(",\n\t\t\tlegend=TRUE")),
	ite(rkwarddev::id(ip.chk.legend, " == \"true\" & ", ip.tvar.group, " != \"\" & ", ip.inp.trace.label, " != \"\""), echo(",\n\t\t\ttrace.label=\"", ip.inp.trace.label, "\"")),
	ite(rkwarddev::id("!", ip.chk.se), echo(",\n\t\t\tci.fun=function(x)c(mean(x, na.rm=TRUE), mean(x, na.rm=TRUE))")),
	rkwarddev::id("echo(", ip.plot.options, ".replace(/, /g, \",\\n\\t\\t\\t\"));"),
	echo(")"),
	plotOpts=ip.plot.options
)

## make a whole component of the interaction plot
plot.component <- rk.plugin.component("Interaction plot",
	xml=list(
		logic=ip.lgc.sect,
		dialog=ip.full.dialog),
	js=list(
		results.header="\"Interaction plot\"",
		require="sciplot",
		doPrintout=ip.js.prnt),
	guess.getter=guess.getter,
	hierarchy=list("plots"),
	create=c("xml", "js"))


#############
## if you run the following function call, files will be written to tempdir!
#############
# this is where it get's serious, that is, here all of the above is put together into one plugin

rk.ANOVA.dir <<- rk.plugin.skeleton(
	about.info,
	path=output.dir,
	guess.getter=guess.getter,
	xml=list(
		logic=lgc.sect,
		dialog=full.dialog),
	js=list(
		require="ez",
		calculate=js.calc,
		printout=js.print,
		load.silencer=var.chk.suppress),
	pluginmap=list(name="ANOVA", hierarchy=list("analysis", "ANOVA")),
	components=list(pttest.component, plot.component, pdata.component),
	dependencies=dependencies.info,
	create=c("pmap", "xml", "js", "desc"),
	overwrite=overwrite,
	tests=FALSE,
#	edit=TRUE,
#	load=TRUE,
#	show=TRUE,
	hints=FALSE)
})
