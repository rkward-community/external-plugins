# the plugin code was generated by this script
# you should not change the plugin code directly, but this script
# note: this script only creates objects in your workspace,
# *EXCEPT* for the last call, see below.

local({
# set the output directory to overwrite the actual plugin
output.dir <- tempdir()
overwrite <- TRUE

require(rkwarddev)

about.info <- rk.XML.about(
	name="rk.FactorAnalysis",
	author=c(
		person(given="Meik", family="Michalke",
			email="meik.michalke@hhu.de", role=c("aut","cre"))),
	about=list(desc="RKWard GUI to conduct principal component and factor analysis",
		version="0.01-9", url="http://rkward.sf.net", long.desc="RKWard GUI to conduct principal component and factor analysis (using the psych package). Also includes dialogs for scree plots, correlation plots, VSS/MAP and parallel analysis."),
	dependencies=list(rkward.min="0.5.6"),
	package=list(c(name="psych", min="1.1.10"))
	)


#############
## principal component & factor analysis
#############
# using principal()/fa() of the package 'psych'

radio.analysis <- rk.XML.radio("Factoring method", options=list(
		"Principal component analysis"=c(val="PCA"),
		"Exploratory factor analysis"=c(val="EFA", chk=TRUE)
	))
radio.corr.type <- rk.XML.radio("Correlation method", options=list(
		"Pearson product-moment (numeric data)"=c(val="fa", chk=TRUE),
		"Polychoric (polytomous data)"=c(val="fa.poly")
	))
var.select <- rk.XML.varselector(label="Select data")
var.data <- rk.XML.varslot(label="Correlation matrix (or raw data matrix)", source=var.select, required=TRUE)

save.results <- rk.XML.saveobj("Save results to workspace", initial="FA.results")

drp.rotation.PCA <- rk.XML.dropdown("Rotation method", options=list(
		"none"=c(val="none"),
		"varimax (orthogonal)"=c(val="varimax", chk=TRUE),
		"quatimax (orthogonal)"=c(val="quatimax"),
		"promax"=c(val="promax"),
		"oblimin"=c(val="oblimin"),
		"simplimax"=c(val="simplimax"),
		"cluster"=c(val="cluster")
	), id.name="drp_PCA_rotate")
drp.rotation.EFA <- rk.XML.dropdown("Rotation method", options=list(
		"None"=c(val="none"),
		"Varimax (orthogonal)"=c(val="varimax"),
		"Quatimax (orthogonal)"=c(val="quatimax"),
		"BentlerT (orthogonal)"=c(val="bentlerT"),
		"GeominT (orthogonal)"=c(val="geominT"),
		"Bifactor (orthogonal)"=c(val="bifactor"),
		"Promax"=c(val="promax"),
		"Oblimin"=c(val="oblimin", chk=TRUE),
		"Simplimax"=c(val="simplimax"),
		"BentlerQ"=c(val="bentlerQ"),
		"GeominQ"=c(val="geominQ"),
		"Biquartimin"=c(val="biquartimin"),
		"Cluster"=c(val="cluster")
	), id.name="drp_EFA_rotate")

drp.factmeth.EFA <- rk.XML.dropdown("Factoring method", options=list(
		"Minimum residual (ULS)"=c(val="minres", chk=TRUE),
		"Weighted least squares (WLS)"=c(val="wls"),
		"Generalized weighted least squares (GLS)"=c(val="gls"),
		"Principal axis"=c(val="pa"),
		"Maximum likelihood"=c(val="ml")
	), id.name="drp_EFA_factmeth")

radio.SMC.EFA <- rk.XML.radio("Initial communality estimate", options=list(
		"Squared multiple correlations"=c(val="true", chk=TRUE),
		"1"=c(val="false")
	))
radio.covar.EFA <- rk.XML.radio("Matrix to factor", options=list(
		"Factor correlation matrix"=c(val="false", chk=TRUE),
		"Factor covariance matrix"=c(val="true")
	))
radio.scrmtx.EFA <- rk.XML.radio("Matrix to score", options=list(
		"Scores based on structure matrix (oblique)"=c(val="true", chk=TRUE),
		"Scores based on pattern matrix"=c(val="false")
	))

# common options
spin.nfactors <- rk.XML.spinbox("Number of factors to extract", min=1, initial=1, real=FALSE)
spin.cutoff <- rk.XML.spinbox("Marker item threshold (cut-off)", initial=0.1)
spin.digits <- rk.XML.spinbox("Show decimals", min=0, initial=3, max=20, real=FALSE)

chk.residuals <- rk.XML.cbox("Show residuals", value="true")
FA.chk.kaiser <- rk.XML.cbox("Apply Kaiser normalization")

drp.scores.EFA <- rk.XML.dropdown("Method to find factor scores", options=list(
	"Regression"=c(val="regression", chk=TRUE),
	"Simple regression (Thurstone)"=c(val="Thurstone"),
	"correlation preserving (ten Berge)"=c(val="tenBerge"),
	"Anderson"=c(val="Anderson"),
	"Bartlett"=c(val="Bartlett")))
drp.missings.PCA <- rk.XML.dropdown("Dealing with missing values", options=list(
	"Don't impute missing values"=c(val="none", chk=TRUE),
	"Replace with median"=c(val="median"),
	"Replace with mean"=c(val="mean")), id.name="radio_missings_PCA")
drp.missings.EFA <- rk.XML.dropdown("Dealing with missing values", options=list(
	"Don't impute missing values"=c(val="none", chk=TRUE),
	"Replace with median"=c(val="median"),
	"Replace with mean"=c(val="mean")), id.name="radio_missings_EFA")
chk.scores <- rk.XML.frame(drp.missings.PCA, label="Find component scores", checkable=TRUE, chk=FALSE)
spin.nobs <- rk.XML.spinbox("Number of observations to find the correlation matrix (GoF statistics)", min=0, initial=0, real=FALSE)

spin.niter <- rk.XML.spinbox("Number of iterations", min=2, initial=2, real=FALSE)
spin.minerr <- rk.XML.spinbox("Until change in communalities is less than", min=0.0001, initial=0.001)
spin.maxiter <- rk.XML.spinbox("Maximum number of iterations", min=2, initial=50, real=FALSE)
chk.iterate <- rk.XML.frame(
	rk.XML.row(
		rk.XML.col(spin.niter),
		rk.XML.col(spin.minerr),
		rk.XML.col(spin.maxiter)
	),
	label="Perform bootstrap iterations", checkable=TRUE, chk=FALSE)

tab1.data <- rk.XML.row(
		var.select,
		rk.XML.col(
			rk.XML.frame(var.data),
			rk.XML.frame(radio.analysis),
			rk.XML.frame(radio.corr.type),
			spin.nfactors,
			rk.XML.stretch(),
			save.results
		)
	)

tab2.options <- rk.XML.row(
		rk.XML.col(
			rk.XML.row(
				rk.XML.col(
					drp.rotation.PCA,
					drp.rotation.EFA
				),
				rk.XML.col(
					drp.factmeth.EFA
				)
			),
			rk.XML.row(
				rk.XML.col(radio.SMC.EFA),
				rk.XML.col(radio.covar.EFA),
				rk.XML.col(radio.scrmtx.EFA)
			),
			rk.XML.frame(
				rk.XML.row(
					rk.XML.col(chk.residuals),
					rk.XML.col(FA.chk.kaiser)
				)
			),
			chk.scores,
			rk.XML.row(
				rk.XML.col(drp.scores.EFA),
				rk.XML.col(drp.missings.EFA)
			),
 			spin.nobs,
			chk.iterate,
 			rk.XML.stretch(),
			rk.XML.frame(
				rk.XML.row(
					rk.XML.col(spin.cutoff),
					rk.XML.col(spin.digits)
				),
			label="Output")
		)
 	)

full.dialog <- rk.XML.dialog(rk.XML.tabbook(label="Factor analysis",
		tabs=list("Data"=tab1.data, "Options"=tab2.options)
	), label="Factor analysis")

## logic section
	lgc.sect <- rk.XML.logic(
		FA.gov.analysis <- rk.XML.convert(sources=list(string=radio.analysis), mode=c(equals="PCA")),
		FA.gov.corr <- rk.XML.convert(sources=list(string=radio.corr.type), mode=c(equals="fa")),
		FA.gov.fa <- rk.XML.convert(sources=list(not=FA.gov.analysis, FA.gov.corr), mode=c(and="")),
		FA.gov.notpoly <- rk.XML.convert(sources=list(FA.gov.analysis, FA.gov.corr), mode=c(or="")),
		rk.XML.connect(governor=FA.gov.analysis, client=drp.rotation.PCA, set="visible"),
		rk.XML.connect(governor=FA.gov.analysis, client=drp.rotation.EFA, set="visible", not=TRUE),
		rk.XML.connect(governor=FA.gov.analysis, client=drp.factmeth.EFA, set="enabled", not=TRUE),
		rk.XML.connect(governor=FA.gov.analysis, client=radio.SMC.EFA, set="enabled", not=TRUE),
		rk.XML.connect(governor=FA.gov.fa, client=radio.covar.EFA, set="enabled"),
		rk.XML.connect(governor=FA.gov.notpoly, client=chk.residuals, set="enabled"),
		rk.XML.connect(governor=FA.gov.analysis, client=radio.scrmtx.EFA, set="enabled", not=TRUE),
		rk.XML.connect(governor=FA.gov.analysis, client=chk.scores, set="visible"),
		rk.XML.connect(governor=FA.gov.analysis, client=drp.scores.EFA, set="visible", not=TRUE),
		rk.XML.connect(governor=FA.gov.fa, client=drp.scores.EFA, set="enabled"),
		rk.XML.connect(governor=FA.gov.analysis, client=drp.missings.EFA, set="visible", not=TRUE),
		rk.XML.connect(governor=FA.gov.analysis, client=chk.iterate, set="enabled", not=TRUE),
		rk.XML.connect(governor=FA.gov.analysis, client=radio.corr.type, set="enabled", not=TRUE)
)

## JavaScript
# discard this object later, we just need the name...
js.frm.score <- rk.JS.vars(chk.scores, modifiers="checked")
js.frm.iterate <- rk.JS.vars(chk.iterate, modifiers="checked")

js.calc <- rk.paste.JS(
	# create a variable for oblique transformations
	"var obrot = new Array(\"promax\", \"oblimin\", \"simplimax\", \"bentlerQ\", \"geominQ\", \"biquartimin\", \"cluster\");\n",
	ite(id("(obrot.indexOf(",drp.rotation.EFA ,") == -1 && ", radio.analysis,
		" != \"PCA\") | (obrot.indexOf(", drp.rotation.PCA ,") == -1 && ", radio.analysis,
		" == \"PCA\")"),
	"isObrot = false;", "isObrot = true;"),
	echo("\tFA.results <- "),
	ite(id(radio.analysis, " == \"PCA\""),
		echo("principal("),
		ite(FA.chk.kaiser,
			echo("kaiser(", radio.corr.type, "("),
			echo(radio.corr.type, "("))),
	ite(var.data, 
		ite(id(radio.analysis, " == \"EFA\" && ", radio.corr.type, " == \"fa.poly\""),
			echo("x=", var.data),
			echo("r=", var.data))),
	ite(id(spin.nfactors, " > 1"), echo(",\n\t\tnfactors=", spin.nfactors)),
	ite(id(radio.analysis, " == \"PCA\" || ", radio.corr.type, " == \"fa\""),
		tf(chk.residuals, opt="residuals")),
	ite(id(radio.analysis, " == \"PCA\""),
		echo(",\n\t\trotate=\"", drp.rotation.PCA, "\""),
		ite(FA.chk.kaiser,
			echo(",\n\t\trotate=\"none\""),
			echo(",\n\t\trotate=\"", drp.rotation.EFA, "\""))),
	ite(id(spin.nobs, " > 0"), echo(",\n\t\tn.obs=", spin.nobs)),
	ite(id(radio.analysis, " == \"PCA\""),
		rk.paste.JS(
			ite(js.frm.score, echo(",\n\t\tscores=TRUE")),
			ite(id(js.frm.score, " & ", drp.missings.PCA, " != \"none\""), echo(",\n\t\tmissing=TRUE,\n\t\timpute=\"", drp.missings.PCA, "\"")),
		level=3),
		rk.paste.JS(
			ite(id(js.frm.iterate), echo(",\n\t\tn.iter=", spin.niter)),
			ite(id(radio.corr.type, " == \"fa\""), echo(",\n\t\tscores=\"", drp.scores.EFA, "\"")),
			ite(id(radio.SMC.EFA, " == \"false\""), echo(",\n\t\tSMC=FALSE")),
			ite(id(radio.corr.type, " == \"fa\" && ", radio.covar.EFA, " == \"true\"" ), echo(",\n\t\tcovar=TRUE")),
			ite(id(drp.missings.EFA, " != \"none\""), echo(",\n\t\tmissing=TRUE,\n\t\timpute=\"", drp.missings.EFA, "\"")),
			ite(id(js.frm.iterate, " & ", spin.minerr, " != 0.001"), echo(",\n\t\tmin.err=", spin.minerr)),
			ite(id(js.frm.iterate, " & ", spin.maxiter, " != 50"), echo(",\n\t\tmax.iter=", spin.maxiter)),
			echo(",\n\t\tfm=\"", drp.factmeth.EFA, "\""),
			ite(id(radio.scrmtx.EFA, " == \"false\"" ), echo(",\n\t\toblique.scores=FALSE")),
		level=3)),
	ite(id(radio.analysis, " == \"EFA\" && ", FA.chk.kaiser), echo("), rotate=\"", drp.rotation.EFA, "\"")),
	echo(")\n\n")
)

js.print <- rk.paste.JS(
	rk.JS.vars(radio.analysis, spin.nfactors, drp.rotation.PCA, drp.factmeth.EFA, drp.rotation.EFA,
		FA.chk.kaiser, spin.digits, spin.cutoff),
	echo("\tdigits <- function(obj) {
		return(format(round(obj, digits=", spin.digits, "), nsmall=", spin.digits, "))
	}
	# Make matrix from loadings, for more flexible output
	FA.load.dim <- dim(FA.results$loadings)
	FA.load.names <- dimnames(FA.results$loadings)
	# Nicen component names
	FA.load.names[[2]] <- paste("),
	ite(id(radio.analysis, " == \"PCA\""),
		echo("\"Component\""),
		echo("\"Factor\"")
	),
	echo(", 1:length(FA.load.names[[2]]))
	FA.load <- FA.results$loadings[!is.character(FA.results$loadings)]
	FA.load.mtx <- matrix(FA.load, nrow=FA.load.dim[1], dimnames=FA.load.names)
	# For printout, highlight loadings
	idx.load <- FA.load >= ", spin.cutoff, "
	FA.load.print <- digits(FA.load)
	FA.load.print[idx.load] <- paste(\"<b>\", FA.load.print[idx.load], \"</b>\", sep=\"\")
	FA.load.print <- matrix(FA.load.print, nrow=FA.load.dim[1], dimnames=FA.load.names)
	# Append communality and uniqueness
	FA.load.print <- cbind(FA.load.print,
		\"communality\"=paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.results$communality), \"</span>\", sep=\"\"),
		\"uniqueness\"=paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.results$uniquenesses), \"</span>\", sep=\"\"))
	# Append sum of squared loadings\n"),
	ite("isObrot",
		echo("\tFA.s2load <- diag(FA.results$Phi %*% t(FA.results$loadings) %*% FA.results$loadings)\n"),
		echo("\tFA.s2load <- colSums(FA.results$loadings^2)\n")
	),
	echo("\t# Variance explained
	FA.varExp <- 100 * FA.s2load / FA.load.dim[1]
	FA.load.print <- rbind(FA.load.print,
		\"Sum of squared loadings\"=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.s2load), \"</span>\", sep=\"\"),
		digits(sum(FA.s2load)), \"\"),
		\"Variance explained (%)\"=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.varExp), \"</span>\", sep=\"\"), \"\", \"\"),
		\"Variance explained (cum %)\"=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(cumsum(FA.varExp)), \"</span>\", sep=\"\"), \"\", \"\"))
	# Finally, make it a data.frame
	FA.load.print <- data.frame(FA.load.print, stringsAsFactors=FALSE)\n"),
	ite("isObrot",
		echo("\t# Prepare correlation matrix for printout
		comp.corr <- digits(FA.results$Phi)
		dimnames(comp.corr) <- list(FA.load.names[[2]],FA.load.names[[2]])\n")
	),
	echo("\t# Prepare score*factors matrix for printout
	scfc.corr <- data.frame(rbind(
		\"Correlation of scores with factors\"=digits(sqrt(FA.results$R2)),
		\"Multiple R square of scores with factors\"=digits(FA.results$R2),
		\"Minimum correlation of possible factor scores\"=digits((2*FA.results$R2)-1)), stringsAsFactors=FALSE)
	colnames(scfc.corr) <- FA.load.names[[2]]

	# Ok, here the actual output starts\n"),
	ite(id(radio.analysis, " == \"PCA\""),
		echo("rk.header(\"Principal Component Analysis\""),
		echo("rk.header(\"Factor Analysis\"")
	),
	echo(",\n\tparameters=list("),
	ite(id(radio.analysis, " == \"PCA\""),
		echo("\t\t\"Number of components\", ", spin.nfactors, ",\n",
		"\t\t\"Rotation\", \"", drp.rotation.PCA, "\""
		),
		rk.paste.JS(
			echo("\t\t\"Number of factors\", ", spin.nfactors, ",\n",
			"\t\t\"Factoring method\", \"", drp.factmeth.EFA,"\",\n",
			"\t\t\"Rotation\", \"", drp.rotation.EFA, "\""),
			ite(FA.chk.kaiser, echo(",\n\t\t\"Normalization\", \"Kaiser\"")),
		level=3)
	),
	echo("))\n"), # end rk.header()
	echo("rk.results(list(
	\"Degrees of freedom\"=FA.results$dof,
	\"Fit\"=digits(FA.results$fit),
	\"Fit (off diag)\"=digits(FA.results$fit.off)
	))\n"),
	echo("rk.header(\"Loadings\", level=4)\n"),
	echo("rk.results(FA.load.print)\n"),
	ite("isObrot",
		echo("rk.header(\"Factor correlations\", level=4)\nrk.results(data.frame(comp.corr, stringsAsFactors=FALSE))\n")
	),
#	echo("rk.header(\"Test of the hypothesis that ", spin.nfactors, " factors are sufficient\", level=4)\n"),
	echo("rk.header(\"Measures of factor score adequacy\", level=4)\n"),
	echo("rk.results(scfc.corr)\n")
)

############
## scree plot
############
scree.var.select <- rk.XML.varselector(label="Select data.frame")
scree.var.data <- rk.XML.varslot(label="Data", source=scree.var.select, required=TRUE)

scree.radio.crv <- rk.XML.radio(label="Draw scree for", options=list(
		"Factors and components"=c(val="both"),
		"Factors only"=c(val="fact"),
		"Prinicipal components only"=c(val="comp")
	))

scree.main <- rk.XML.input(label="Main title", initial="Scree plot")

scree.hline.frm <- rk.XML.frame(
	scree.hline <- rk.XML.spinbox(label="Eigenvalue", min=0, initial=1),
		checkable=TRUE, chk=TRUE, label="Horizontal line")

scree.preview <- rk.XML.preview()

scree.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		scree.var.select,
		rk.XML.col(
			scree.var.data,
			scree.main,
			scree.radio.crv,
			scree.hline.frm,
			rk.XML.stretch(),
			scree.preview
# 			rk.XML.frame(var.dv, var.wid),
# 			rk.XML.frame(var.within, var.between)
		)
	)
, label="Scree plot")

## JavaScript
scree.js.print <- rk.paste.JS(
	scree.chk.hline <- rk.JS.vars(scree.hline.frm, modifiers="checked"),
	rk.paste.JS.graph(
		echo("\t\tscree("),
		ite(scree.var.data, echo("\n\t\t\t", scree.var.data)),
		ite(id(scree.radio.crv, " == \"comp\""), echo(",\n\t\t\tfactors=FALSE")),
		ite(id(scree.radio.crv, " == \"fact\""), echo(",\n\t\t\tpc=FALSE")),
		ite(id(scree.main, " != \"Scree plot\""), echo(",\n\t\t\tmain=\"", scree.main, "\"")),
		ite(scree.chk.hline,
			rk.paste.JS(ite(id(scree.hline, " != 1"), echo(",\n\t\t\thline=", scree.hline)), level=1),
			echo(",\n\t\t\thline=-1")),
		echo(")")
	)
)

## make a whole component
scree.component <- rk.plugin.component("Scree plot",
	xml=list(
		dialog=scree.full.dialog),
	js=list(
		require="psych",
		doPrintout=scree.js.print),
	hierarchy=list("analysis", "Factor analysis","Number of factors"),
	create=c("xml", "js"))


############
## Horn's parallel analysis
############
prll.var.select <- rk.XML.varselector(label="Select data.frame/matrix")
prll.var.data <- rk.XML.varslot(label="Data", source=prll.var.select, required=TRUE)

# minres, ml, uls, wls, gls, pa
prll.factmeth <- rk.XML.dropdown("Factoring method", options=list(
		"Minimum residual (ULS)"=c(val="minres", chk=TRUE),
		"Weighted least squares (WLS)"=c(val="wls"),
		"Generalized weighted least squares (GLS)"=c(val="gls"),
		"Principal axis"=c(val="pa"),
		"Maximum likelihood"=c(val="ml")
	), id.name="drp_prll_factmeth")


prll.radio.crv <- rk.XML.radio(label="Show Eigen values for", options=list(
		"Factors and components"=c(val="both"),
		"Factors only"=c(val="fa"),
		"Prinicipal components only"=c(val="pc")
	))

prll.main <- rk.XML.input(label="Main title", initial="Parallel Analysis Scree Plots")
# prll.ylabel <- rk.XML.input(label="Y axis", initial="Eigen values of factors and components")

prll.spin.nobs <- rk.XML.spinbox("Number of observations (0 implies raw data)", min=0, initial=0, real=FALSE)

prll.spin.niter <- rk.XML.spinbox("Number of iterations", min=2, initial=20, real=FALSE)

prll.cbox.smc <- rk.XML.cbox("Estimate communalities by SMCs")

prll.cbox.error.bars <- rk.XML.cbox("Plot error bars")

prll.cbox.legend <- rk.XML.cbox("Show legend", chk=TRUE)

prll.preview <- rk.XML.preview()

prll.save.results <- rk.XML.saveobj("Save data to workspace", initial="parallel.data")


prll.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		prll.var.select,
		rk.XML.col(
			prll.var.data,
			prll.main,
			prll.radio.crv,
			prll.factmeth,
			prll.spin.nobs,
			prll.spin.niter,
			prll.cbox.smc,
			prll.cbox.error.bars,
			prll.cbox.legend,
			rk.XML.stretch(),
			prll.save.results,
			prll.preview
		)
	)
, label="Parallel analysis")

## JavaScript
prll.js.print <- rk.paste.JS.graph(
	echo("\t\tparallel.data <- fa.parallel("),
	ite(prll.var.data, echo("\n\t\t\t", prll.var.data)),
	ite(id(prll.spin.nobs, " != 0"), echo(",\n\t\t\tn.obs=", prll.spin.nobs)), # NULL
	ite(id(prll.factmeth, " != \"minres\""), echo(",\n\t\t\tfm=\"", prll.factmeth, "\"")),
	ite(id(prll.radio.crv, " != \"both\""), echo(",\n\t\t\tfa=\"", prll.radio.crv, "\"")),
	ite(id(prll.main, " != \"Parallel Analysis Scree Plots\""), echo(",\n\t\t\tmain=\"", prll.main, "\"")),
	ite(id(prll.spin.niter, " != 20"), echo(",\n\t\t\tn.iter=", prll.spin.niter)),
	tf(prll.cbox.error.bars, opt="error.bars", level=4), # FALSE
	tf(prll.cbox.smc, opt="SMC", level=4), # FALSE
	# prll.ylabel # NULL
	tf(prll.cbox.legend, opt="show.legend", true=FALSE, not=TRUE, level=4), # TRUE
	echo(")")
)

## make a whole component
prll.component <- rk.plugin.component("Parallel analysis (Horn)",
	xml=list(
		dialog=prll.full.dialog),
	js=list(
		require="psych",
		doPrintout=prll.js.print),
	hierarchy=list("analysis", "Factor analysis","Number of factors"),
	create=c("xml", "js"))

############
## VSS & MAP
############
# vss(x, n = 8, rotate = "varimax", diagonal = FALSE, fm = "minres", n.obs=NULL,plot=TRUE,title="Very Simple Structure",...)

vss.var.select <- rk.XML.varselector(label="Select data.frame/matrix")
vss.var.data <- rk.XML.varslot(label="Data", source=vss.var.select, required=TRUE)

# minres, ml, uls, wls, gls, pa
vss.factmeth <- rk.XML.dropdown("Factoring method", options=list(
		"Minimum residual factoring (ULS)"=c(val="minres", chk=TRUE),
		"Principal component analysis"=c(val="pc"),
		"Principal axis factor analysis"=c(val="pa"),
		"Maximum likelihood factor analysis"=c(val="ml")
	), id.name="drp_vss_factmeth")

vss.drp.rotation <- rk.XML.dropdown("Rotation method", options=list(
		"None"=c(val="none"),
		"Varimax (orthogonal)"=c(val="varimax", chk=TRUE),
		"Promax"=c(val="promax"),
		"Oblimin"=c(val="oblimin")
	), id.name="drp_vss_rotate")

vss.spin.nfactors <- rk.XML.spinbox("Number of factors to extract", min=1, initial=8, real=FALSE)

vss.main <- rk.XML.input(label="Main title", initial="Very Simple Structure")

vss.spin.nobs <- rk.XML.spinbox("Number of observations", min=0, initial=1000, real=FALSE)

vss.cbox.diag <- rk.XML.cbox("Fit the diagonal as well")

# plot options
vss.cbox.line <- rk.XML.cbox("Connect different complexities")
vss.preview <- rk.XML.preview()
vss.frame.plot <- rk.XML.frame(
	vss.main,
	vss.cbox.line,
	vss.preview, label="Plot results", checkable=TRUE)

vss.save.results <- rk.XML.saveobj("Save data to workspace", initial="VSS.data")

vss.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		vss.var.select,
		rk.XML.col(
			vss.var.data,
			vss.factmeth,
			vss.spin.nobs,
			vss.drp.rotation,
			vss.cbox.diag,
			rk.XML.stretch(),
			vss.frame.plot,
			vss.save.results
		)
	)
, label="VSS/MAP")

## logic section
	vss.lgc.sect <- rk.XML.logic(
		vss.gov.factmeth <- rk.XML.convert(sources=list(string=vss.factmeth), mode=c(equals="ml")),
		rk.XML.connect(governor=vss.gov.factmeth, client=vss.spin.nobs, set="enabled")
	)

## JavaScript
vss.js.calc <- rk.paste.JS(
	echo("\t\tVSS.data <- VSS("),
	ite(vss.var.data, echo("\n\t\t\t", vss.var.data)),
	ite(id(vss.spin.nobs, " != 0"), echo(",\n\t\t\tn.obs=", vss.spin.nobs)), # NULL
	ite(id(vss.factmeth, " != \"minres\""), echo(",\n\t\t\tfm=\"", vss.factmeth, "\"")),
	ite(id(vss.drp.rotation, " != \"varimax\""), echo(",\n\t\t\trotate=\"", vss.drp.rotation, "\"")),
	tf(vss.cbox.diag, opt="diagonal", level=4), # FALSE
	echo(",\n\t\t\tplot=FALSE)\n"),
	echo("\n\t\tvss.stat.vars <- c(\"dof\",\"chisq\",\"prob\",\"sqresid\",\"fit\",\"cfit.1\",\"cfit.2\")\n",
	"\n\t\tvss.stat.results <- as.data.frame(cbind(Factors=1:length(VSS.data[[\"map\"]]), MAP=VSS.data[[\"map\"]], VSS.data[[\"vss.stats\"]][,vss.stat.vars]))\n",
	"\t\tcolnames(vss.stat.results)[3:9] <- paste(\"VSS\", vss.stat.vars, sep=\".\")\n\n",
	"\t\tmin.MAP <- which.min(VSS.data[[\"map\"]])\n",
	"\t\tmin.VSS1 <- which.min(VSS.data[[\"cfit.1\"]])\n",
	"\t\tmin.VSS2 <- which.min(VSS.data[[\"cfit.2\"]])\n\n")
)

vss.js.print <- rk.paste.JS(
	vss.js.frame.plot <- rk.JS.vars(vss.frame.plot, modifiers="checked"),
#  	echo("rk.print(VSS.data[[\"call\"]])\n"),
	ite(vss.js.frame.plot, rk.paste.JS.graph(
		echo("\t\tVSS.plot(VSS.data"),
		ite(id(vss.main, " != \"Very Simple Structure\""), echo(",\n\t\t\ttitle=\"", vss.main, "\"")),
		tf(vss.cbox.line, opt="line", level=4),
		echo(")")
	)),
	echo("rk.header(\"Very Simple Structure\", level=4)\n",
	"rk.print(paste(\"VSS complexity 1 achieves a maximimum of \", round(VSS.data[[\"cfit.1\"]][min.VSS1], digits=3), \" with \", min.VSS1, \" factors.\", sep=\"\"))\n",
	"rk.print(paste(\"VSS complexity 2 achieves a maximimum of \", round(VSS.data[[\"cfit.2\"]][min.VSS2], digits=3), \" with \", min.VSS2, \" factors.\", sep=\"\"))\n",
	"rk.header(\"Minimum Average Partial\", level=4)\n",
	"rk.print(paste(\"The Velicer MAP criterion achieves a minimum of \", round(VSS.data[[\"map\"]][min.MAP], digits=3), \" with \", min.MAP, \" factors.\", sep=\"\"))\n",
	"rk.header(\"Statistics\", level=4)\n",
	"rk.results(vss.stat.results)\n\n")
)

## make a whole component
vss.component <- rk.plugin.component("Very Simple Structure/Minimum Average Partial",
	xml=list(
		logic=vss.lgc.sect,
		dialog=vss.full.dialog),
	js=list(
		require="psych",
		calculate=vss.js.calc,
		doPrintout=vss.js.print),
	hierarchy=list("analysis", "Factor analysis","Number of factors"),
	create=c("xml", "js"))


############
## correlation plot
############
crplt.var.select <- rk.XML.varselector(label="Select data")
crplt.var.data <- rk.XML.varslot(label="Data (correaltaion/factor matrix)",
	source=crplt.var.select,
#	classes=c("data.frame", "matrix"),
	required=TRUE)

crplt.main <- rk.XML.input(label="Main title", initial="Correlation plot")

crplt.radio.colors <- rk.XML.radio(label="Colors", options=list(
		"Red to Blue"=c(val="true", chk=TRUE),
		"Greyscale"=c(val="false")
	))
crplt.spin.shades <- rk.XML.spinbox(label="Number of shades", min=2, initial=51, real=FALSE)

crplt.spin.lower <- rk.XML.spinbox(label="from", min=-1, max=1, initial=-1)
crplt.spin.upper <- rk.XML.spinbox(label="to", min=-1, max=1, initial=1)
crplt.range <- rk.XML.frame(rk.XML.row(rk.XML.col(crplt.spin.lower),rk.XML.col(crplt.spin.upper)), label="Range of correlation values to color")

crplt.spin.nlabels <- rk.XML.spinbox(label="Number of categories in legend", min=1, initial=10, real=FALSE)

crplt.preview <- rk.XML.preview()

crplt.full.dialog <- rk.XML.dialog(
	rk.XML.row(
		crplt.var.select,
		rk.XML.col(
			crplt.var.data,
			crplt.radio.colors,
			crplt.range,
			crplt.spin.shades,
			rk.XML.stretch(),
			crplt.main,
			crplt.chk.lables <- rk.XML.frame(crplt.spin.nlabels,
				checkable=TRUE, chk=TRUE, label="Show legend"),
			crplt.preview
		)
	),
	label="Correlation plot")

## JavaScript
crplt.js.print <- rk.paste.JS(
	js.chk.lables <- rk.JS.vars(crplt.chk.lables, modifiers="checked"),
	rk.paste.JS.graph(
		echo("\t\tcor.plot("),
		ite(crplt.var.data, echo("\n\t\t\tr=", crplt.var.data)),
		ite(id(crplt.radio.colors, " == \"false\""), echo(",\n\t\t\tcolors=FALSE")),
		ite(id(crplt.spin.shades, " != 51"), echo(",\n\t\t\tn=",crplt.spin.shades)),
		ite(id(crplt.main, " != \"Correlation plot\""), echo(",\n\t\t\tmain=\"", crplt.main, "\"")),
		ite(id(crplt.spin.lower, " != -1 | ", crplt.spin.upper, " != 1"),
			echo(",\n\t\t\tzlim=c(",crplt.spin.lower,",",crplt.spin.upper, ")")),
		ite(js.chk.lables,
			rk.paste.JS(
				ite(id(crplt.spin.nlabels, " != 10"), echo(",\n\t\t\tn.legend=", crplt.spin.nlabels)),
				level=1),
			echo(",\n\t\t\tshow.legend=FALSE")),
		echo("\n\t\t)")
	)
)

## make a whole component
crplt.component <- rk.plugin.component("Correlation plot",
	xml=list(
		dialog=crplt.full.dialog),
	js=list(results.header="\"Correlation plot\"",
		require="psych",
 		doPrintout=crplt.js.print),
	hierarchy=list("plots", "Factor analysis"),
	create=c("xml", "js"))


#############
## if you run the following function call, files will be written to tempdir!
#############
# this is where it get's serious, that is, here all of the above is put together into one plugin

rk.FactorAnalysis.dir <<- rk.plugin.skeleton(
	about.info,
	path=output.dir,
	xml=list(
		logic=lgc.sect,
		dialog=full.dialog),
	js=list(
		globals="var isObrot;",
		results.header=FALSE,
		require="psych",
		calculate=js.calc,
		printout=js.print),
	pluginmap=list(name="Factor analysis", hierarchy=list("analysis", "Factor analysis")),
	components=list(
		scree.component,
		crplt.component,
		prll.component,
		vss.component),
	create=c("pmap", "xml", "js", "desc"),
	overwrite=overwrite,
	tests=FALSE,
#	edit=TRUE,
#	show=TRUE,
	load=TRUE)
})
